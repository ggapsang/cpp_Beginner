#include <stdio.h>
#include <stdlib.h>

int main()
{
	// 포인터 변수
	// 자료형 변수
	int* pInt = nullptr;

	// 주소를 저장
	// int는 주소로 접근 했을 때, 그 메모리 공간 안에 값을 int로 읽겠다는 뜻이다

	char* pChar = nullptr;
	short* pShort = nullptr;

	// 포인터 변수의 크기는 다 같다(주소에 접근해서 메모리를 해석하는 방식이 다를 뿐)
	// 그렇다면 포인터 변수의 크기는 몇 바이트인가? 
	// 운영체제(플렛폼)에 따라 포인터 변수의 크기가 다 다르다
	// 32비트 운영체제 : 4바이트([단위로 데이터를 처리함]) -> 2^32 = 42억가지 = 4GB정도 (32비트 운영체제에 램 4기가 이상 꽂아도...)
	// 64비트 운영체제 : 8바이트 -> 2^64 = 42억 * 42억 (4GB 램 42억개...ㄷㄷ)
	// 포인터는 8바이트이다(64비트 운영체제에서)

	int iSize = sizeof(int*);

	// 주소를 나타내는 포인터 값은 정수형의 표현을 따르고 있다
	
	int i = 0;
	pInt = &i;

	pInt += 1; // 주소값을 1 증가시켜라 -> (i가 100번지이므로, 101이 아니라, 다음 int 위치는 4바이트이므로 104로 가야 한다)
	// char 포인터의 +1은 1증가, short의 +1은 2증가
	// 포인터 변수의 증감은 자료형의 크기만큼의 증가이다

	// 포인터와 배열
	// 배열의 특징
	// 1. 메모리가 연속적인 구조이다
	// 2. 배열의 이름은 배열의 시작 주소이다
	int iArr[10] = {}; //정수값을 할당하기 위한 메모리 공간 10개. 연속적으로 이어져 있음

	iArr; //배열의 시작 주소

	iArr + 1; //포인터이므로 실제로는 4가 더해진다

	*iArr; //주소에 있는 값을 정수로 해석하며 접근하게 된다
	*(iArr + 1) = 10; //배열에 시작으로부터 1칸 떨어진 곳에 접근하여 10을 넣는다

	// 첫번째 주소에 값을 할당하려면
	*iArr = 10; //이므로
	*(iArr + 0) = 10; //이라 해석할 수 있다. 이것이 바로 배열의 index가 0인 이유이다

	iArr[0] = 10; // 이 수식은 *(iArr + 0) = 10의 축약형이다(offset이 0) *MSDN (마소 개발자 네트워크) 공식 입장
	iArr[1] = 20; // 이 수식은 *(iArr + 0) = 10의 축약형이다(offset 1)
	// 매우 중요: 이 모든 것은 배열의 위치가 연속적으로 되어 있기 때문에 가능한 일 

	return 0;
}
